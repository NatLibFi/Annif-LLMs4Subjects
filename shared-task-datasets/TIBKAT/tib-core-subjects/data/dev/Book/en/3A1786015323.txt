Research software engineering with Python : building software that makes research possible
Welcome0.1The Big Picture0.2 Intended Audience0.3 What You Will Learn0.4 Using this Book0.5 Contributing and Re-Use0.6 AcknowledgmentsGetting Started1.1 Project Structure1.2 Downloading the Data1.3 Installing the Software1.4 Summary1.5 Exercises1.6 Key PointsThe Basics of the Unix Shell2.1 Exploring Files and Directories2.2 Moving Around2.3 Creating New Files and Directories2.4 Moving Files and Directories2.5 Copying Files and Directories2.6 Deleting Files and Directories2.7 Wildcards2.8 Reading the Manual2.9 Summary2.10 Exercises2.11 Key PointsBuilding Tools with the Unix Shell3.1 Combining Commands3.2 How Pipes Work3.3 Repeating Commands on Many Files3.4 Variable Names3.5 Redoing Things3.6 Creating New Filenames Automatically3.7 Summary3.8 Exercises3.9 Key PointsGoing Further with the Unix Shell4.1 Creating New Commands4.2 Making Scripts More Versatile4.3 Turning Interactive Work into a Script4.4 Finding Things in Files4.5 Finding Files4.6 Configuring the Shell4.7 Summary4.8 Exercises .4.9 Key PointsBuilding Command-Line Tools with Python5.1 Programs and Modules5.2 Handling Command-Line Options5.3 Documentation5.4 Counting Words5.5 Pipelining5.6 Positional and Optional Arguments5.7 Collating Results5.8 Writing Our Own Modules5.9 Plotting5.10 Summary5.11 Exercises5.12 Key PointsUsing Git at the Command Line6.1 Setting Up6.2 Creating a New Repository6.3 Adding Existing Work6.4 Describing Commits6.5 Saving and Tracking Changes6.6 Synchronizing with Other Repositories6.7 Exploring History6.8 Restoring Old Versions of Files6.9 Ignoring Files6.10 Summary6.11 Exercises6.12 Key PointsGoing Further with Git7.1 What's a Branch?7.2 Creating a Branch7.3 What Curve Should We Fit?7.4 Verifying Zipf's Law7.5 Merging7.6 Handling Conflicts7.7 A Branch-Based Workflow7.8 Using Other People's Work7.9 Pull Requests7.10 Handling Conflicts in Pull Requests7.11 Summary7.12 Exercises7.13 Key PointsWorking in Teams8.1 What is a Project?8.2 Include Everyone8.3 Establish a Code of Conduct8.4 Include a License8.5 Planning8.6 Bug Reports8.7 Labeling Issues8.8 Prioritizing8.9 Meetings8.10 Making Decisions8.11 Make All This Obvious to Newcomers8.12 Handling Conflict8.13 Summary8.14 Exercises8.15 Key PointsAutomating Analyses with Make9.1 Updating a Single File9.2 Managing Multiple Files9.3 Updating Files When Programs Change9.4 Reducing Repetition in a Makefile9.5 Automatic Variables9.6 Generic Rules9.7 Defining Sets of Files9.8 Documenting a Makefile9.9 Automating Entire Analyses9.10 Summary9.11 Exercises9.12 Key PointsConfiguring Programs10.1 Configuration File Formats10.2 Matplotlib Configuration10.3 The Global Configuration File10.4 The User Configuration File10.5 Adding Command-Line Options10.6 A Job Control File10.7 Summary10.8 Exercises10.9 Key PointsTesting Software11.1 Assertions11.2 Unit Testing11.3 Testing Frameworks11.4 Testing Floating-Point Values11.5 Integration Testing11.6 Regression Testing11.7 Test Coverage11.8 Continuous Integration11.9 When to Write Tests11.10 Summary11.11 Exercises11.12 Key PointsHandling Errors12.1 Exceptions12.2 Writing Useful Error Messages12.3 Testing Error Handling12.4 Reporting Errors12.5 Summary12.6 Exercises12.7 Key PointsTracking Provenance13.1 Data Provenance13.2 Code Provenance13.3 Summary13.4 Exercises13.5 Key PointsCreating Packages with Python14.1 Creating a Python Package14.2 Virtual Environments14.3 Installing a Development Package14.4 What Installation Does14.5 Distributing Packages14.6 Documenting Packages14.7 Software Journals14.8 Summary14.9 Exercises14.10 Key PointsFinale15.1 Why We Wrote This BookAppendixA SolutionsB Learning ObjectivesC Key PointsD Project TreeE Working RemotelyF Writing Readable CodeG Documenting ProgramsH YAMLI AnacondaJ GlossaryK ReferencesIndex
