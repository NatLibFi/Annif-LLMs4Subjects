Proceedings of the fifth HPI Cloud Symposium "Operating the Cloud" 2017
Versionsverwaltung ist unter Softwareentwicklern weit verbreitet. Sie verringert das Risiko beim Ändern der Software und erlaubt den Entwicklern verschiedene Konfigurationen zu verwalten und effizienter zusammenzuarbeiten. Dies wird durch Plattformen zum Teilen von Code wie GitHub oder Bitbucket zusätzlich unterstützt. Die meisten Versionsverwaltungssysteme verfolgen Dateien (z.B. Git, Mercurial und Subversion), aber manche Programmierumgebungen arbeiten nicht mit Dateien, sondern mit Objekten (viele Smalltalk-Implementierungen tun dies). Nutzer dieser Umgebungen möchten Versionsverwaltung für ihre Objekte dennoch einsetzen können. Spezialisierte Versionsverwaltungssysteme, wie die für Smalltalk verfügbaren (z.B. ENVY/Developer und Monticello), konzentrieren sich auf Methoden, Klassen und Konfigurationen selbiger. Andere von Benutzern definierte und konstruierte Objekte können damit oftmals gar nicht oder nur über komplizierte Umwege erfasst werden oder es wird ein fest vorgegebenes Format zur Serialisierung verwendet, das nicht für alle Arten von Objekten gleichermaßen geeignet ist. Desweiteren können beliebte, bereits existierende Plattformen für dateibasierte Versionsverwaltung von diesen Systemen nicht verwendet werden oder Adapterlösungen müssen implementiert und gepflegt werden. Um die Situation von Versionsverwaltung für beliebige Objekte zu verbessern, stellt diese Arbeit ein Framework zum Nachverfolgen, Konvertieren und Speichern von Objekten vor. Es erlaubt Editionen von Objekten in einem austauschbaren, bestehenden Backend-Versionsverwaltungssystem zu speichern. Plattformen für dieses System können daher weiterbenutzt werden. Nutzer und Objekte können beeinflussen, wie Objekte zur Versionsverwaltung erfasst werden. Domänenspezifische Anforderungen lassen sich umsetzen. Das Speicherformat (d.h. das Dateiformat, wenn ein dateibasiertes Backend benutzt wird) kann auch von Objekt zu Objekt anders sein. Verschiedene Editionen von Objekten können verglichen und Änderungen auf Objektgraphen übertragen werden. Ein allgemeiner Ansatz zum Erfassen und Wiederherstellen von Objekten wird beschrieben, welcher jedes Objekt als eine Ansammlung von Slots betrachtet. Dadurch können Nutzer sofort anfangen ihre Objekte zu versionieren, ohne dass sie ihre Objekte zunächst zur Versionsverwaltung erweitern müssen. Die vorgeschlagene Architektur wird anhand einer Prototyp-Implementierung evaluiert, die es erlaubt Objekte in Squeak/Smalltalk mit Git zu versionieren. Der Prototyp verbessert den oben beschriebenen benachteiligten Status von Benutzerobjekten im Bezug auf Versionsverwaltung und erleichtert auch manche Versionsverwaltungs-Operationen für Klassen und Methoden. Er fördert auch neue Probleme zutage, die ebenfalls in dieser Arbeit diskutiert werden. Insofern ist diese Arbeit als ein erster Schritt in Richtung vollumfänglicher Versionsverwaltung für beliebige Objekte zu betrachten.
Version control is a widely used practice among software developers. It reduces the risk of changing their software and allows them to manage different configurations and to collaborate with others more efficiently. This is amplified by code sharing platforms such as GitHub or Bitbucket. Most version control systems track files (e.g., Git, Mercurial, and Subversion do), but some programming environments do not operate on files, but on objects instead (many Smalltalk implementations do). Users of such environments want to use version control for their objects anyway. Specialized version control systems, such as the ones available for Smalltalk systems (e.g., ENVY/Developer and Monticello), focus on a small subset of objects that can be versioned. Most of these systems concentrate on the tracking of methods, classes, and configurations of these. Other user-defined and user-built objects are either not eligible for version control at all, tracking them involves complicated workarounds, or a fixed, domain-unspecific serialization format is used that does not equally suit all kinds of objects. Moreover, these version control systems that are specific to a programming environment require their own code sharing platforms; popular, well-established platforms for file-based version control systems cannot be used or adapter solutions need to be implemented and maintained. To improve the situation for version control of arbitrary objects, a framework for tracking, converting, and storing of objects is presented in this report. It allows editions of objects to be stored in an exchangeable, existing backend version control system. The platforms of the backend version control system can thus be reused. Users and objects have control over how objects are captured for the purpose of version control. Domain-specific requirements can be implemented. The storage format (i.e. the file format, when file-based backend version control systems are used) can also vary from one object to another. Different editions of objects can be compared and sets of changes can be applied to graphs of objects. A generic way for capturing and restoring that supports most kinds of objects is described. It models each object as a collection of slots. Thus, users can begin to track their objects without first having to implement version control supplements for their own kinds of objects. The proposed architecture is evaluated using a prototype implementation that can be used to track objects in Squeak/Smalltalk with Git. The prototype improves the suboptimal standing of user objects with respect to version control described above and also simplifies some version control tasks for classes and methods as well. It also raises new problems, which are discussed in this report as well.
