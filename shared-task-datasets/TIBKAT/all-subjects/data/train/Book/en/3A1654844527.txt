Erlang and Elixir for Imperative Programmers
Part 1: Before we start -- Chapter 1: Imperative vs. Functional Programming -- Chapter 2: From Erlang to Elixir -- Chapter 3: Setting your Mind -- Chapter 4: Service Overview and Design -- Chapter 5: Service Features -- Chapter 6: Environment and Deployment -- Chapter 7: Development Setup -- Chapter 8: Production Setup -- Chapter 9: Overview -- Chapter 10: Public Interface -- Chapter 11: Asset Processing -- Chapter 12: Deployment -- Chapter 13: Overview Patterns and Concepts -- Chapter 14: Functional Concepts -- Chapter 15: Type Creation Concepts -- Chapter 16: Code Structuring Concepts -- Appendix A: Modeling -- Appendix B: Resources -- Appendix C: Features-Framework-Concepts Matrix -- Appendix D: Quick Guide to Erlang and Elixir.
Learn and understand Erlang and Elixir and develop a working knowledge of the concepts of functional programming that underpin them. This book takes the authorâ€™s experience of taking on a project that required functional programming and real-time systems, breaks it down, and organizes it. You will get the necessary knowledge about differences to the languages you know, where to start, and where to go next. Have you been told by your customer or manager that they heard good things about Erlang, you should use it for the next project? Never had to deal with functional programming or real-time systems? In 2014, the author, Wolfgang Loder, developed a repository for digital assets that had to deliver those assets in binary form quickly and reliably, being able to deal with at least hundreds of requests per second. Since he could decide the architecture and software stack of the solution, he immediately thought of Erlang and its libraries and started to evaluate this option. It was not long after that he discovered Elixir, which sits on top of the Erlang virtual machine and has features more palatable for non-functional programmers, although it is a functional programming language itself. Erlang and Elixir for Imperative Programmers gives you a basis for deciding whether the effort is viable for your next project. This book is partly a tale of the author's own experience and partly a description of the bigger and more subtle differences between Erlang/Elixir and languages such as C++, Java, and C#. What You'll Learn Discover functional programming, Erlang, and Elixir Work on service design and service features Set up your environment: deployment, development, and production Implement the service including public interface, asset processing, and deployment Use the patterns and concepts found in Erlang including type creation concepts and code structuring. Who This Book Is For Experienced and savvy programmers, coders, and developers new to Erlang and Elixir.
