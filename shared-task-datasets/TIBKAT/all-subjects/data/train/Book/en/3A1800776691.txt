Exploring the dataflow supercomputing paradigm : example Algorithms for Selected Applications
Intro -- Preface -- Contents -- Contributors -- Part I Theoretical Issues -- 1 Method of Big-Graph Partitioning Using a Skeleton Graph -- 1.1 Introduction -- 1.1.1 Proposed Method of Graph Partitioning -- 1.1.2 Contributions -- 1.1.3 Overview -- 1.2 Distributed Triple-Store Setup -- 1.2.1 Architecture -- 1.2.2 Distributed Query Execution System -- 1.3 Formalization and Statistics -- 1.3.1 Formalization -- 1.3.2 Computing Statistics -- 1.4 Graph Partitioning Method -- 1.4.1 Semantic Distribution -- 1.4.2 Computing Skeleton Graph -- 1.4.3 Clustering Skeleton Graph -- 1.4.4 Triple-Pattern Localization -- 1.4.5 Related Work -- 1.5 Empirical Evaluation -- 1.5.1 Benchmark Environment -- 1.5.2 Benchmark Results on Different Distribution Algorithms -- 1.6 Conclusion -- References -- 2 On Cloud-Supported Web-Based Integrated Development Environment for Programming DataFlow Architectures -- 2.1 Introduction -- 2.2 The Control-Flow Hardware -- 2.3 The DataFlow Hardware -- 2.4 The Maxeler Framework -- 2.5 The MaxIDE Framework -- 2.6 The WebIDE Framework -- 2.7 Conclusion -- References -- Part II Applications in Mathematics -- 3 Minimization and Maximization of Functions: Golden-Section Search in One Dimension -- 3.1 Introduction -- 3.2 Existing Solutions -- 3.3 Essence of the DataFlow Paradigm -- 3.4 Minimization or Maximization of Functions -- 3.4.1 Unimodality -- 3.5 Golden-Section Search -- 3.5.1 Derivation of the Method -- 3.5.2 The control-flow Implementation -- 3.5.3 The DataFlow Implementation -- 3.6 Performance Evaluation -- 3.6.1 MAX4 Card Usage Evaluation -- 3.6.2 Execution Time -- 3.6.3 Test Examples -- 3.6.4 Test Results and Comparison with control-flow paradigm -- 3.6.5 Cluster Testing -- 3.7 Conclusion -- References -- 4 Matrix-Based Algorithms for DataFlow Computer Architecture: An Overview and Comparison -- 4.1 Introduction.
