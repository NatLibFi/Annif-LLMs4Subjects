Functional Interfaces in Java : Fundamentals and Examples
1: Functional Interfaces -- 2: Lambda Expressions -- 3: Predicates -- 4: Functions -- 5: Operators -- 6: Consumers -- 7: Suppliers -- 8: Use in Traversing Objects -- 9: Use in Collections -- 10: Use in Comparing Objects -- 11: Use in Optionals -- 12: Use in Streams -- 13: Use in Multithreaded Programs -- 14: Use in Atomic Calculations -- 15: Use in JavaFX Applications -- Appendix A: Method References
Reduce development time by organizing your programs as chains of functional interfaces and see that the advantages of using functional interfaces include the flexibility and power of inlined functional chains and reuse of functional methods utilized throughout the Java API. Youâ€™ll see how complex logical expressions can be reduced to chains of predicates and how chains of comparators can be used to sort data by several criteria in order. Other examples include streams that utilize functional interfaces to filter, sort, transform, and perform calculations on data; CompletableFutures that use functional interfaces to create cascading and parallel execution threads; and JavaFX programs that use functional interfaces to monitor the data backed by their graphical components. Each chapter contains a complete programming project: the Discount Dave project shows you how to qualify car customers by organizing questions as a list of predicates; the Real Estate Broker project shows you how to use chains of comparators to filter and sort homes according to customer priorities; the Dave's Part Inventory project shows you how to query and write reports from an inventory database using stream operations; and the Sentence Builder project shows you how to correct a sentence by implementing each grammar rule as a separate link in a future chain. Functional Interfaces in Java will help you quickly develop powerful and reliable programs that utilize functional interfaces to implement logic and calculations. You will: Use the functional interfaces in the java.util.function package to perform conditional logic, transform and generate data, and perform calculations Filter and sort data by several criteria using comparators Process collections and filter, sort, transform, and reduce stream elements with functional interfaces Write cascading and parallel execution threads
