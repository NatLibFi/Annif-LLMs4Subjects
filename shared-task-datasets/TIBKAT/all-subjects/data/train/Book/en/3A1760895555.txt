Data parallel C++ : mastering DPC++ for programming of heterogeneous systems using C++ and SYCL
Learn how to accelerate C++ programs using data parallelism. Data parallelism in C++ enables access to parallel resources in a modern heterogeneous system, freeing you from being locked into any particular computing device. Now a single C++ application can use any combination of devices—including GPUs, CPUs, FPGAs and AI ASICs—that are suitable to the problems at hand. This open access book enables C++ programmers to be at the forefront of this exciting and important new development that is helping to push computing to new levels. It is full of practical advice, detailed explanations, and code examples to illustrate key topics. This book teaches data-parallel programming using C++ and the SYCL standard from the Khronos Group and walks through everything needed to use SYCL for programming heterogeneous systems. The book begins by introducing data parallelism and foundational topics for effective use of SYCL and Data Parallel C++ (DPC++), the open source compiler used in this book. Later chapters cover advanced topics including error handling, hardware-specific programming, communication and synchronization, and memory model considerations. You will learn: • How to accelerate C++ programs using data-parallel programming • How to target multiple device types (e.g. CPU, GPU, FPGA) • How to use SYCL and SYCL compilers • How to connect with computing’s heterogeneous future via Intel’s oneAPI initiative.
Chapter 1: Introduction -- Chapter 2: Where code executes -- Chapter 3: Data management and ordering the uses of data -- Chapter 4: Expressing parallelism -- Chapter 5: Error handling -- Chapter 6: USM in detail -- Chapter 7: Buffers in detail -- Chapter 8: DAG scheduling in detail -- Chapter 9: Local memory and work-group barriers -- Chapter 10: Defining kernels -- Chapter 11: Vectors -- Chapter 12: Device-specific extension mechanism -- Chapter 13: Programming for GPUs -- Chapter 14: Programming for CPUs -- Chapter 15: Programming for FPGAs -- Chapter 16: Address spaces and multi_ptr -- Chapter 17: Using libraries -- Chapter 18: Working with OpenCL -- Chapter 19: Memory model and atomics.
