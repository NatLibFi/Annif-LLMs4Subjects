Adaptive code : agile coding with design patterns and SOLID principles
Write code that can adapt to changes. By applying this book's principles, you can create code that accommodates new requirements and unforeseen scenarios without significant rewrites. Gary McLean Hall describes Agile best practices, principles, and patterns for designing and writing code that can evolve more quickly and easily, with fewer errors, because it doesn't impede change. Now revised, updated, and expanded, Adaptive Code, Second Edition adds indispensable practical insights on Kanban, dependency inversion, and creating reusable abstractions. Drawing on over a decade of Agile consulting and development experience, McLean Hall has updated his best-seller with deeper coverage of unit testing, refactoring, pure dependency injection, and more. Master powerful new ways to: Write code that enables and complements Scrum, Kanban, or any other Agile framework;  Develop code that can survive major changes in requirements;  Plan for adaptability by using dependencies, layering, interfaces, and design patterns;  Perform unit testing and refactoring in tandem, gaining more value from both;  Use the "golden master" technique to make legacy code adaptive;  Build SOLID code with single-responsibility, open/closed, and Liskov substitution principles;  Create smaller interfaces to support more-diverse client and architectural needs; Leverage dependency injection best practices to improve code adaptability;  Apply dependency inversion with the Stairway pattern, and avoid related anti-patterns. This book is for programmers of all skill levels seeking more-practical insight into design patterns, SOLID principles, unit testing, refactoring, and related topics. Most readers will have programmed in C#, Java, C++, or similar object-oriented languages, and will be familiar with core procedural programming techniques. -- Provided by publisher
Introduction to Scrum -- Introduction to Kanban -- Dependencies and layering -- Interfaces and design patterns -- Testing -- Refactoring -- The single responsibility principle -- The ope/closed principle -- The Liskov substitution principle -- Interface segregation -- Dependency inversion -- Dependency injection -- Coupling, cohesion, and connascence
