Representing and reasoning with qualitative preferences : tools and applications
7. CRISNER: a practically efficient reasoner for qualitative preferences -- 1. Overview -- 1.1 Justification of query answers -- 1.2 Tool architecture -- 1.3 Preference queries -- 2. XML input language -- 2.1 Defining preference variables -- 2.2 Specifying conditional preference statements -- 2.3 Specifying relative importance preferences -- 3. Encoding preferences as SMV models -- 3.1 Encoding preference variables & auxiliary variables -- 3.2 Encoding preference statements -- 3.3 Justification of query results -- 4. Architecture -- 4.1 Extending CRISNER -- 4.2 Scalability -- 5. Concluding remarks --
This book provides a tutorial introduction to modern techniques for representing and reasoning about qualitative preferences with respect to a set of alternatives. The syntax and semantics of several languages for representing preference languages, including CP-nets, TCP-nets, CI-nets, and CP-theories, are reviewed. Some key problems in reasoning about preferences are introduced, including determining whether one alternative is preferred to another, or whether they are equivalent, with respect to a given set of preferences. These tasks can be reduced to model checking in temporal logic. Specifically, an induced preference graph that represents a given set of preferences can be efficiently encoded using a Kripke Structure for Computational Tree Logic (CTL). One can translate preference queries with respect to a set of preferences into an equivalent set of formulae in CTL, such that the CTL formula is satisfied whenever the preference query holds. This allows us to use a model checker to reason about preferences, i.e., answer preference queries, and to obtain a justification as to why a preference query is satisfied (or not) with respect to a set of preferences. This book defines the notions of the equivalence of two sets of preferences, including what it means for one set of preferences to subsume another, and shows how to answer preferential equivalence and subsumption queries using model checking. Furthermore, this book demonstrates how to generate alternatives ordered by preference, along with providing ways to deal with inconsistent preference specifications. A description of CRISNER.an open source software implementation of the model checking approach to qualitative preference reasoning in CP-nets, TCP-nets, and CP-theories is included, as well as examples illustrating its use
2. Qualitative preference languages -- 1. Preliminaries -- 1.1 Notation -- 1.2 Succinct preference specification -- 2. Qualitative preference languages -- 2.1 Representing qualitative preferences -- 2.2 Preference semantics -- 2.3 CP-nets -- 2.4 TCP-nets -- 2.5 CP-theories -- 2.6 CI-nets -- 2.7 Relative expressive power -- 3. Reasoning with qualitative preferences -- 3.1 Ceteris Paribus preference semantics -- 3.2 Semantics for a preference specification as induced preference graphs -- 3.3 Dominance and consistency in qualitative preference languages -- 4. Complexity of reasoning --
8. Postscript -- A. SMV model listings -- 1. SMV model listing for PCP -- 2. Dominance query and NuSMV output for PCP -- 3. SMV model listing for PTCP -- 4. Dominance query and NuSMV output for PTCP -- 5. SMV model listing for PTCP -- 6. Dominance query and NuSMV output for PCPT -- B. Providing XML input to CRISNER -- 1. XML input listing for PCP -- 2. XML input listing for PTCP -- 3. XML input listing for PCPT -- C. SMV models & CTL queries for preference equivalence and subsumption -- 1. SMV model for K(PCP, PTCP) -- 2. SMV model for K (PTCP, PCPT) -- 3. SMV model for K (PCPT, PCP) -- 4. Preference subsumption query PTCP - PCP on K (PTCP, PCP)-- 5. Preference subsumption query PCP - PTCP on K (PCP, PTCP) -- 6. Preference subsumption query PTCP - PCPT on K (PTCP, PCPT) -- 7. Preference subsumption query PCPT - PTCP on K (PCPT, PTCP) -- 8. Preference subsumption query PCP - PCPT on K (PCPT, PTCP) -- 9. Preference subsumption query PCPT - PTCP on K (PCPT, PCP) -- Bibliography -- Authors' biographies
6. Ordering alternatives with respect to preference -- 1. Overview -- 1.1 Kripke encoding -- 1.2 Objective: computing an ordered sequence -- 2. Computation of ordered alternative sequence -- 2.1 Dealing with SCCs in induced preference graph -- 2.2 Iterative model refinement and property relaxation -- 2.3 Sample run of the algorithm on example in figure 6.1(b) -- 2.4 Number of model checking calls -- 3. Properties of NEXT-PREF -- 4. Summary --
5. Verifying preference equivalence and subsumption -- 1. Preference equivalence and preference subsumption -- 2. Data structures to represent semantics of two sets of preference -- 2.1 Inverse induced preference graph -- 2.2 Combined induced preference graph -- 3. Kripke structure encoding for preference equivalence and subsumption -- 3.1 Modeling of preference semantics: extension for preference equivalence and preference subsumption reasoning -- 3.2 Encoding combined induced preference graph as Kripke structure -- 4. Querying K (P1, P2) for subsumption -- 4.1 Extracting a proof of non-subsumption -- 4.2 Verifying preference equivalence -- 5. Discussion --
3. Model checking and computation tree logic -- 1. Introduction -- 2. Kripke structure -- 3. Computation tree temporal logic -- 3.1 Syntax -- 3.2 Semantics -- 4. Model checking algorithm -- 5. NuSMV model checker -- 5.1 NuSMV language & counterexamples --
4. Dominance testing via model checking -- 1. Dominance testing of unconditional preferences -- 1.1 Syntax of L -- 1.2 Semantics of L -- 1.3 Properties of unconditional dominance relation -- 1.4 Complexity of dominance testing in L -- 1.5 Expressiveness, preference reasoning via model checking -- 2.1 Kripke structure encoding of induced preference graph -- 2.2 Correctness of the construction of K (P) -- 3. Answering dominance queries via model checking -- 3.1 Verifying dominance -- 3.2 Extracting a proof of dominance -- 3.3 Summary and discussion --
1. Qualitative preferences -- 1. Motivating examples -- 1.1 Cyberdefense policy -- 1.2 Education -- 1.3 Software engineering -- 1.4 Countermeasures for network security -- 1.5 Minimizing credential disclosure -- 2. Organization of the book --
